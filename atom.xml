<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[GSoC 2013 - RTEMS Virtualization Layer Project]]></title>
  <link href="http://phipse.github.io/rtems/atom.xml" rel="self"/>
  <link href="http://phipse.github.io/rtems/"/>
  <updated>2013-08-01T11:27:32+02:00</updated>
  <id>http://phipse.github.io/rtems/</id>
  <author>
    <name><![CDATA[Philipp Eppelt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Midterm explanation]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/30/midterm-explanation/"/>
    <updated>2013-07-30T11:42:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/30/midterm-explanation</id>
    <content type="html"><![CDATA[<p>It is midterm evaluation time, so half the time is up and I want to write about
the changes I bring into the RTEMS project. This post will explain the patch I
created for midterm.</p>

<!--more-->


<h2>Overview</h2>

<p>I brought one major change to the project, the split of the i386 architecture
dependent code into a part in score and another part in libcpu.
Compared to this the virtualization layer consisting of two header files, one
for CPU dependent functionality and on for board dependent, is rather small.
The introduction of the new BSP called virtPOK is a bigger change, but still,
it only affects this project and not all building upon the i386 architecture.</p>

<h2>i386 split</h2>

<p>i386 has several instructions (hlt, cli, sti) which are not allowed in a
virtualized environment, as they affect other virtual machines. Functions in
cpukit/score/cpu/i386/ are using these instruction and therefore need to be
moved. However, these functions must remain in the native version of an RTEMS
i386 binary, but must be replaced with different implementations in a virtual
compilation.</p>

<p>RTEMS is providing with libcpu a place where CPUs with special features of the
same architecture can be specified. That is the place where the native and
virtual implementations of the mentioned functions need to go.
I introduced two new CPU models for the i386 architecture &ndash; native and virtual.
Native is used by the pc386-BSPs and should work like before. Virtual is the
new kid in the block and is only used by the virtPok BSP.</p>

<p>Configure.ac is controlling the choice of the bsp. As the config file for a BSP
specifies the CPU model, the virtPok.cfg is specifying <strong><em>virt-pok</em></strong> as CPU.
Configure.ac checks for this CPU model and sets a conditional if this model is
used. The conditional controls the path of execution in the corresponding
Makefile.am, which in turn chooses the virtual or native directory.</p>

<h2>Virtualization layer</h2>

<p>The virtualization layer consists of two parts: One for the CPU and one for the
BSP. My intention for the layer is to provide on BSP using the functionality of
the layer and then the layer must be implemented by the host/hypervisor and
provided as a library to RTEMS.</p>

<p>The CPU part needs to be implemented in RTEMS once for each architecture. The
BSP currently developed for i386 might be reusable on other architectures, as
the host cares for architecture dependent parts.</p>

<p>Both header files virtLayerBSP.h and virtLayerCPU.h can be found in
c/src/lib/libbsp/i386/virtPok/include/ .</p>

<h2>Virtual BSP</h2>

<p>The virtual BSP for i386 is called virtPok and is currently able to run the
hello world sample virtualized on POK. The BSP mimics the interface between
RTEMS and the host/hypervisor, by forwarding the RTEMS function calls to the
virtualization layer, which is implemented by the host and provided as a
library to the BSP. Currently implemented is a console driver to run the hello
world sample. A clock driver will be the next step but this needs changes in
POK first.</p>

<h2>Putting it all together</h2>

<p>To rebuild the current work, you can either checkout my virt-bsp branch from
<a href="https://github.com/phipse/rtems">github</a></p>

<p>Or you can apply the patches from the rtems-devel mailing list to the current
RTEMS git head.</p>

<p>Then you need to follow my explanations from the <a href="http://phipse.github.io/rtems/blog/2013/07/08/HelloWorld/" title="Hello World">Hello
World</a>
blog post.</p>

<p>Unfortunately, you need to build RTEMS with <strong>make -j1</strong> as parallel
compilation can lead to undefined reference errors.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generation of libpart target]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/28/generation-of-libpart-target/"/>
    <updated>2013-07-28T19:22:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/28/generation-of-libpart-target</id>
    <content type="html"><![CDATA[<p>This post is about code generation in POK and how the libpart target can be
included in the automatic generation process. First I will discuss where the
configuration for the generation is done; Second I talk about the reasons, why
I won&rsquo;t intercept this process and which solution I settled with.</p>

<!--more-->


<h2>How Makefiles are generated</h2>

<p>Like the name &lsquo;generated-code&rsquo; would suggest, every file below this directory
is generated by ocarina. But I wondered: Where are the specifications for this
process?
After a vain search through the POK sources I looked at the ocarina sources.
Where else could the specs be? And here are a couple of files name
<strong>ocarina-backends-pok_c-* </strong>. One of them is named
<strong>ocarina-backends-pok_c-makefiles.adb</strong> and in the procedure
<strong>Visit_Processor_Instance</strong> the main Makefile is written. Right below the
kernel Makefile is created, too. Every line that shows up in the generated
Makefiles is specified here and depending on your architecture and BSP it is
written out.
But where are the partition Makefiles created?
In the procedure <strong>Visit_Process_Or_Device_Instance</strong>. And here we are the
point where I want to include libpart as an Makefile to be included and as a
target.</p>

<h2>Get libpart into the generation</h2>

<p>To get libpart into the Makefile generation I need to change ocarina source
code. I don&rsquo;t like this idea. I don&rsquo;t want to get into a third project. But do
I have to, even if I don&rsquo;t want to?</p>

<p>Why did I want my own makefile target in the first place?
Usually, POK is build for embedded devices and the virtualization capability is
not in the main focus of the system. Libpart is a custom to the virtualization
of RTEMS and is not necessary for everything else. So fusing the build of
libpart into the partition target, would build it even if it is not needed.
That is the case for nearly every system.</p>

<p>On the other hand libpok is only generated at compile time and doesn&rsquo;t
influence the binary. So it has no impact on the performance of the target
system and a tiny compile time addition isn&rsquo;t noticeable on todays systems.</p>

<p>After reconsidering the decision process I will try to build libpart together
with the partition, without modifying ocarina.
I just included the current libpart make rule in the prerequisites of the
target rule in <strong>rules-partition.mk</strong> but unfortunatly it isn&rsquo;t that easy, as
the <strong>$+</strong> opartor is trying to include libpart in the binary.
The second target mentioned in the partition&rsquo;s makefile is libpok. But as
libpart depends on libpok I can&rsquo;t use libpart as prerequisite for libpok.
The current solution is to build libpart under the libpok target and adding the
$(OBJS) as prerequisite.</p>

<p>I rebuild the <strong>rtems-guest</strong> example without errors and compared the nm output
of a former libpart.a with the new one. It was equal. To test if the change
broke something I ran <strong>make test</strong>. All test cases compiled successfully.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How late is it?]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/09/how-late-is-it/"/>
    <updated>2013-07-09T00:00:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/09/how-late-is-it</id>
    <content type="html"><![CDATA[<p>The big question is: How can we pass the time to RTEMS?
POK doesn&rsquo;t provide a mechanism to pass time to a partition, however, the partition can
ask how late it is. But this doesn&rsquo;t help. Hence, we need to design a new
mechanism in POK and RTEMS to let the two work together.</p>

<p><em>Caution</em>: This is a very long post!</p>

<!--more-->


<h2>What we need &hellip;</h2>

<h3>.. in POK</h3>

<ul>
<li>Forward interrupts to registered partitions</li>
<li>Register several partitions to the same interrupt, aka interrupt chaining</li>
<li>Keep a count for every partition&rsquo;s pending interrupt</li>
<li>Checkpointing the time in the scheduler at partition entry and exit</li>
</ul>


<h3>.. in RTEMS</h3>

<ul>
<li>A time warp function to cover the time, when the partition was not scheduled</li>
</ul>


<h2>Current interrupt control in POK (x86)</h2>

<h3>Registering a handler</h3>

<p>This an excerpt from several files: pit.c, time.h</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define CLOCK_HANDLER pok_tick_counter +=1; pok_sched();</span>
</span><span class='line'>
</span><span class='line'><span class="n">INTERRUPT_HANDLER</span> <span class="p">(</span><span class="n">pit_interrupt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">frame</span><span class="p">;</span>
</span><span class='line'>  <span class="n">pok_pic_eoi</span><span class="p">(</span><span class="n">PIT_IRQ</span><span class="p">)</span>
</span><span class='line'>  <span class="n">CLOCK_HANDLER</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">pok_bsp_irq_register</span> <span class="p">(</span><span class="n">PIT_IRQ</span><span class="p">,</span> <span class="n">pit_interrupt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>The function <em>pok_bsp_irq_register</em> is defined in bsp.c:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pok_ret_t</span> <span class="nf">pob_bsp_irq_register</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">pok_pic_unmask</span> <span class="p">(</span><span class="n">irq</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pok_arch_event_register</span> <span class="p">(</span><span class="mi">32</span> <span class="o">+</span> <span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">POK_ERRNO_OK</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And in turn <em>pok_arch_event_register</em> is defined in arch.c:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pok_ret_t</span> <span class="nf">pok_arch_event_register</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">pok_idt_set_gate</span> <span class="p">(</span> <span class="n">vector</span><span class="p">,</span> <span class="n">GDT_CORE_CODE_SEGMENT</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">handler</span><span class="p">,</span>
</span><span class='line'>            <span class="n">IDTE_TRAP</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">POK_ERROR_OK</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This last function is defined in event.c and is setting up an idt_entry_t.</p>

<p>This shows two things: First, the number of the occurring interrupt isn&rsquo;t passed on to the
handler. Second, one vector refers to one entry in the idt table and therefore
one interrupt can only invoke one handler.</p>

<h3>Interrupt chaining &amp;&amp; counting pending ones</h3>

<ul>
<li><p>Handler list
Instead of one handler, keep a list of handler functions registered to that
specific interrupt.
But the handler is converted into an so called offset_low and offset_high.
Therefore, I don&rsquo;t think this is a good solution.</p></li>
<li><p>Meta handler
Define a meta handler object, which registers a requested interrupt and keeps
track of every registered handler.
Additionally, it could keep a count of pending interrupts to each partition.</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">meta_handler</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">handler_list</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span>  <span class="n">reg_handler</span><span class="p">[</span><span class="n">POK_CONFIG_NB_PARTITIONS</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">pending</span><span class="p">[</span><span class="n">POK_CONFIG_NB_PARTITIONS</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">vector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">receive_irq</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">POK_CONFIG_NB_PARTITIONS</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">POK_SHED_CURRENT_PARTITION</span> <span class="o">&amp;&amp;</span> <span class="n">reg_handler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
</span><span class='line'>        <span class="n">pending</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="n">reg_handler</span><span class="p">[</span><span class="n">POK_SHED_CURRENT_PARTITION</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
</span><span class='line'>      <span class="n">meta_deliver_irq</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">meta_deliver_irq</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">reg_handler</span><span class="p">[</span><span class="n">POK_SCHED_CURRENT_PARTITION</span><span class="p">]();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">register_meta_handler</span><span class="p">(</span> <span class="kt">uint16_t</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">vector</span> <span class="o">=</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'>    <span class="n">reg_handler</span><span class="p">[</span><span class="n">POK_SHED_CURRENT_PARTITION</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pending</span><span class="p">[</span><span class="n">POK_SHED_CURRENT_PARTITION</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">pok_idt_set_gate</span><span class="p">(</span> <span class="n">vector</span><span class="p">,</span> <span class="n">GDT_CORE_CODE_SEGMENT</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">this</span><span class="p">.</span><span class="n">receive_irq</span><span class="p">(),</span> <span class="n">IDTE_TRAP</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>Why don&rsquo;t I use a dynamically growing linked list?
The execution time is equal every time it is run. This eases estimations.</p></li>
<li><p>Why do I use the POK_SHED_CURRENT_PARTITION as an index into the arrays?
Both arrays will be in sync all the time, as they don&rsquo;t grow and shrink
dynamically.</p></li>
<li><p>Improvements?
I could define an array containing the registered partition indexes and a
counter counting the number of registered partitions. This would prevent me to
run over all POK_CONFIG_NB_PARTITIONS in the for-loop.</p></li>
</ul>


<h3>Forwarding Interrupts</h3>

<p>The proposed meta_handler doesn&rsquo;t solve the problem of just forwarding the
interrupts. I still need to register a handler for every interrupt and it is
still missing the ability to pass along the vector number.</p>

<p>Either I build custom handler, containing the IRQ number for each IRQ or I
change the POK handler model to accept one variable.
As the meta handler is capable of adding the vector number on the fly, the
latter is possible.
However, the interrupt handler are generated by assembly code, which I need to
understand first.</p>

<h3>Scheduler Time Checkpoints</h3>

<p>The POK scheduler needs to keep track of each partition entry and exit, so it
can tell the partition how many clock ticks it missed. I haven&rsquo;t come around to
take a look at the scheduler implementation and how this can be inserted, but
on the other hand I think, that pending clock interrupts will pretty much have
the same effect. They accumulate during the time the partition is off-line and
are delivered, when it comes on-line again. This part needs <em>discussion</em>.</p>

<h3>RTEMS Time Warp</h3>

<p>Due to the round robin scheduling, the RTEMS guest will run until it has
consumed it&rsquo;s time slice and then wait for the rest of the major frame to pass.
This leads to a drift between RTEMS execution time and wall-clock time, which
is unacceptable for a real-time system.</p>

<p>To reduce the drift, RTEMS will time warp every time it is scheduled. The time
warp will apply all ticks to the RTEMS internal counters. This can either be
done via a checkpoint extension in the scheduler or via pending clock
interrupts. As mentioned above this needs to be discussed.</p>

<p>During this time warp deadlines might be missed, but this is more a matter of
system design, than of wrong behavior on the time side.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World - describing the build process]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/08/HelloWorld/"/>
    <updated>2013-07-08T00:00:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/08/HelloWorld</id>
    <content type="html"><![CDATA[<p>The good news first: Hello World runs!</p>

<p>To get there you need five steps:</p>

<ol>
<li>Build the rtems-guest example in POK.</li>
<li>Copy libpart.a part1/ to virtPok/</li>
<li>Build virtPok BSP</li>
<li>Copy hello binary to POK partition and rebuild kernel binary</li>
<li>make run</li>
</ol>


<!--more-->


<h3>1. Build the rtems-guest example</h3>

<p>I assume you have checked out my POK fork and ran make configure.</p>

<ul>
<li>Change directory to ${POK}/examples/rtems-guest/</li>
<li>Run make</li>
<li>Change directory to generated-code/cpu/</li>
<li>Copy the last line in part1/Makefile and change rules-common in rules-libpart</li>
<li>Add libpart to <em>TARGET</em></li>
<li>Execute &lsquo;make partitions&rsquo;</li>
</ul>


<h3>2. Copy libpart.a</h3>

<p>The last step created a library file called libpart.a in part1/ directory.
This file must be moved to RTEMS.</p>

<p>cp ${POK}/examples/rtems-guest/generated-code/cpu/part1/libpart.a \
  ${RTEMS}/c/src/lib/libbsp/i386/virtPok/</p>

<h3>3. Build RTEMS</h3>

<p>Now you are ready to build RTEMS with the virtPok BSP.</p>

<ul>
<li>Create a build directory next to your RTEMS directory, I assume it is called
&lsquo;b-virtPok&rsquo;.</li>
<li>cd b-virtPok</li>
<li>Configure RTEMS with the following:
../rtems/configure &mdash;target=i386-rtems4.11 &mdash;enable-rtemsbsp=virtPok &mdash;enable-cxx &mdash;disable-networking &mdash;disable-posix &mdash;enable-maintainer-mode</li>
<li>make</li>
</ul>


<p>This process will sucessfully build the hello sample, but will fail on the next
one.</p>

<h3>4. Copy hello sample elf and build the final kernel binary again</h3>

<p>The compiled binary is ready to be run as a partition on POK.</p>

<p>Copy the compiled hello.exe ELF binary to replace the partition binary.</p>

<p>cp ${Builddir}/virtPok-i386/c/virtPok/testsuite/samples/hello/hello.exe \</p>

<pre><code>${POK}/examples/rtems-guest/generated-code/cpu/part1/part1.elf
</code></pre>

<p>Now we need to generate the partition table again and link the kernel binary
again:</p>

<ul>
<li>cd ${POK}/examples/rtems-guest/generated-code/cpu/</li>
<li>make build-kernel</li>
</ul>


<h3>5. Run qemu</h3>

<p>Change your directory to ${POK}/examples/rtems-guest/ and execute &lsquo;make run&rsquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory partition and pointers]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/07/Modeling-the-partition/"/>
    <updated>2013-07-07T00:00:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/07/Modeling-the-partition</id>
    <content type="html"><![CDATA[<p>I had the issue, that the file POK uses as buffer to tell the kernel what to
print on the screen, was outside of the partition. Well, outside as in the
filepointer was pointing to a memory location, which was outside the memory
slice configured in the AADL model (model.aadl).
So when modelling the partition, that should contain the guest, keep in mind to
define enough memory for the binary.</p>

<p>As you can see the kernel uses the model.aadl parameters to check the partition,
even if your ELF binary is using different memory sizes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GDB hell - maybe you get lucky]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/07/GDB-hell/"/>
    <updated>2013-07-07T00:00:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/07/GDB-hell</id>
    <content type="html"><![CDATA[<p>How the heck can I debug this monster? I can show you how to survive at least a
couple of minutes.</p>

<!--more-->


<h2>POK Partitions and GDB</h2>

<p>How a POK partition can be debugged in general can be read in the POK
Developer Documentation included in the repository.</p>

<p>I assume you have build POK, build RTEMS with the library provided by the POK
partition, injected the RTEMS binary as part1.elf into POK and build the kernel
again.</p>

<p>So you execute <em>make run-gdb</em> in rtems-guest/. Qemu will be started and pauses
before it starts the guest aka POK.
Now go to generated-code/cpu/ (just to shorten filenames, not necessary) and:
* Invoke <em>gdb pok.elf</em>.
* Connect to the target <em>target remote :1234</em>
* break pok_loader_load_partition  // tab completion can be used
* continue
* do some single stepping until
* p pok_partitions[0].base_addr contains something != 0
* add_symbol_file part1/part1.elf pok_partitions[0].base_addr and confirm
now you can set breakpoints on functions in POK and RTEMS, e.g.:
* b bsp_start
* b virt_charWrite
* b printf
* b my_fflush
* b pok_core_syscall</p>

<p><em>symbol-file part1/part1.elf</em> will swap pok.elf for part1/part1.elf; now the
function names from the RTEMS partition are shown. You can swap part1.elf with
pok.elf when you enter the kernel.</p>

<p>Unfortunately, next and single don&rsquo;t work, but si and ni do.
The backtrace command <em>bt</em> will most likely just show you the current function
and not the previous one. It will just be 0x00000 &hellip; .
But maybe you get lucky.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RTEMS i386 split - How to support a virtualized CPU]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/05/RTEMS-World/"/>
    <updated>2013-07-05T00:00:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/05/RTEMS-World</id>
    <content type="html"><![CDATA[<p>There are several x86 instructions that are not allowed in a virtualized
environment. Hence, I introduced a new CPU model called <em>virtual</em> in the i386
branch of RTEMS, which is equal to the <em>native</em> branch, except sensitive
instructions like hlt, cli, sli.</p>

<!--more-->


<h2>score/cpu, libcpu/, virtual, native and the CPU model conditional</h2>

<p>In a virtual environment a client is not allowed to halt the CPU or mess with
the interrupt flag. Therefore, we need a CPU model avoiding these instructions
and using a different way to tell the hypervisor, to not deliver interrupts.</p>

<p>In RTEMS several CPU models can be provided for one architecture in the libcpu/
directory. Therefore the BSP defines a flag <strong>RTEMS_CPU_MODEL</strong> in the BSP&rsquo;s
config file, e.g. libbsp/i386/virtPok/make/custom/virtPok.cfg.
In libcpu the configure.ac file contains a check for the RTEMS_CPU_MODEL name
and defines a variable usable in Makefile.am.
Using this method different CPU models of the same architecture can be defined.</p>

<p>In my configuration RTEMS_CPU_MODEL=virt-pok and the variable generated by
configure.ac is <em>VIRT_POK</em>. The Makefile branches conditionally depending on
this variable, choosing a different directory: <em>native</em> or <em>virtual</em>.</p>

<p>cpukit/score/cpu/i386/ contains the basic architecture files. In this directory
no function containing a sensitive instruction is allowed. A list of the
functions and in which files they are can be found
<a href="http://wiki.rtems.org/wiki/index.php/GSOC_2013_-_Paravirtualization_of_RTEMS">on the wiki page</a>.</p>

<p>I moved these functions to new files and placed the files containing the
original functions in the <em>native</em> branch of the libcpu/i386/ directory and
modified the <em>virtual</em> functions to use the virtualization layer functions
defined in virtLayerCPU.h.</p>

<h2>virtPok BSP</h2>

<p>Actually this BSP could also be named virtualBSP or hypervisorBSP, as at the
end all calls to the hardware should instead go to the virtualization layer &ndash;
virtLayerBSP.h. So it is not dependent on the used host system.</p>

<p>virtPok/include contains both header files: virtLayerCPU.h and virtLayerBSP.h.
Both header files must be considered in Makefile.am and are therefore added to
<em>include_HEADERS</em>.
The most interesting part in Makefile.am is the rule to append the library
provided by the host: <strong>libpart.a</strong>, to libbsp.a. Unfortunately, libpok.a can&rsquo;t
be appended right away. Instead it must be extracted, the .lo files need to be
renamed to .o files and then all .o files from libpart.a can be appended to
libbsp.a.</p>

<p>This BSP doesn&rsquo;t need to initialize hardware, so the start/_start.S code is
much shorter than on actual hardware. Basically, it just provides the entry
point calling boot_card() and if that returns a call to bsp_reset.</p>

<p><em>linkcmds</em> is much more interesting, as it has to ensure POK gets a binary file
it recognizes. Therefore, ENTRY(start) is set. The rest is the same as in
pc386, but some changes will be made in the future.</p>

<p>The last part considered up to now is the console. As HelloWorld wants to write
to the screen, we need a working console driver. However, we cannot make any
assumptions about the hardware. Hence, if we want to write to the console, we
call virt_charWrite(), defined in virtLayerBSP.h.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POK Model and changes to the build system]]></title>
    <link href="http://phipse.github.io/rtems/blog/2013/07/05/POK-World/"/>
    <updated>2013-07-05T00:00:00+02:00</updated>
    <id>http://phipse.github.io/rtems/blog/2013/07/05/POK-World</id>
    <content type="html"><![CDATA[<p>I will discuss the POK code and model written to contain the final
RTEMS-POK-Partition-binary and changes and additions to the build system to
generate the necessary library.</p>

<!--more-->


<h2>POK libpart</h2>

<p>Up to now POK does not generate a library containing all object files of one
partition, referring to everything in libpok.a and the user defined code
(hello.c). This is done by adding a new makefile target called libpart.</p>

<p>It will build a library libpart.a containing all object files generated by the
user code and all generated files from libpok.a and resides in each partitions
directory.</p>

<p>However, up to now you have to add it by hand to part1/Makefile after invoking
<em>make</em> in the projects root directory (rtems-guest), the ocarina run overwrites
changes to any file in generated-code. Details in <strong>HelloWorld &ndash; describing the
link process</strong>.</p>

<h2>POK example code</h2>

<p>I used the <em>partitioned-threads</em> example as a starting point for my
<em>rtems-guest</em> code. Additionally the header files describing the RTEMS
virtualization layer are copied, namely virtLayerBSP.h and virtLayerCPU.h.
The model.aadl (model) is reduced to generate only one partition.
The hello.c file includes the virtLayer*.h files and implements the defined
functions.</p>

<p>Assuming that POK is configured and the $POK_PATH is set <em>make</em> will check
model and user code and generate the partition and kernel accordingly.</p>

<p>To ensure that POK and RTEMS are using the same calling convention every
function in the virtualization layer has the attribute <strong>fastcall</strong>.</p>
]]></content>
  </entry>
  
</feed>
